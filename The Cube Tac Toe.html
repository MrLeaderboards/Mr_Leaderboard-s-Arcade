<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>3D Cubix Tic‑Tac‑Toe (Player vs AI)</title>
<style>
  body {
    margin: 0;
    background: #0a0f1c;
    color: white;
    font-family: Arial, Helvetica, sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
  }
  #ui {
    padding: 10px;
    background: rgba(255,255,255,0.03);
    display: flex;
    gap: 12px;
    align-items: center;
  }
  button, select {
    padding: 8px 12px;
    background: #162033;
    border: 1px solid #2c3650;
    color: white;
    border-radius: 6px;
    cursor: pointer;
  }
  #gameCanvas {
    flex: 1;
    width: 100%;
    height: 100%;
    display: block;
  }
  span.stat { font-size: 14px; }
</style>
</head>
<body>
<div id="ui">
  <span class="stat">Wins: <strong id="wins">0</strong></span>
  <span class="stat">Losses: <strong id="losses">0</strong></span>
  <span class="stat">Draws: <strong id="draws">0</strong></span>
  <button id="restart">New Game</button>
  <select id="starter">
    <option value="human">Player starts (X)</option>
    <option value="ai">AI starts (X)</option>
  </select>
  <span id="status">Loading…</span>
</div>
<canvas id="gameCanvas"></canvas>

<!-- Using a stable three.js build. If this fails replace with your preferred CDN version. -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Defensive wrapper to capture WebGL/Shader errors and display a friendly message
window.addEventListener('error', (ev) => {
  // If it's a WebGL shader error it'll contain "WebGLProgram" or "shader"
  const s = document.getElementById('status');
  if (ev && ev.message && /WebGLProgram|shader/i.test(ev.message)){
    console.error('WebGL shader error detected:', ev.message);
    s.textContent = 'WebGL shader error — try a different browser or update graphics drivers. See console for details.';
  }
});

try {
  /* --- 3D SCENE SETUP --- */
  const canvas = document.getElementById('gameCanvas');
  if (!canvas) throw new Error('Canvas element not found');

  // Clamp devicePixelRatio to avoid extremely high DPR causing driver shader issues
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(DPR);
  renderer.setClearColor(0x07111b);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
  camera.position.set(0, 0, 7);
  camera.lookAt(0,0,0);

  const light = new THREE.PointLight(0xffffff, 1);
  light.position.set(5,5,5);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x404040));

  function resizeRenderer(){
    const uiH = document.getElementById('ui').offsetHeight || 48;
    const w = Math.max(100, window.innerWidth);
    const h = Math.max(100, window.innerHeight - uiH);
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }

  // Controls-like rotation
  let rotX = 0, rotY = 0;
  let isDrag = false;
  let prevX = 0, prevY = 0;

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('mousedown', e => { isDrag = true; prevX = e.clientX; prevY = e.clientY; });
  window.addEventListener('mouseup', () => isDrag = false);
  canvas.addEventListener('mouseleave', () => isDrag = false);
  canvas.addEventListener('mousemove', e => {
    if (!isDrag) return;
    rotY += (e.clientX - prevX) * 0.01;
    rotX += (e.clientY - prevY) * 0.01;
    prevX = e.clientX;
    prevY = e.clientY;
  });

  /* --- GAME LOGIC --- */
  let board = Array(27).fill(null);
  let current = 'X';
  let human = 'X';
  let ai = 'O';
  let running = false;

  const idx = (x,y,z)=> z*9 + y*3 + x;
  const cells = [];

  /* --- CREATE 27 CUBES --- */
  const cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  function createBoard3D() {
    // Remove existing children safely
    while(cubeGroup.children.length) cubeGroup.remove(cubeGroup.children[0]);
    cells.length = 0;

    const geo = new THREE.BoxGeometry(0.9,0.9,0.9);

    for (let z=0; z<3; z++){
      for (let y=0; y<3; y++){
        for (let x=0; x<3; x++){
          const mat = new THREE.MeshStandardMaterial({ color: 0x1e293b });
          const cube = new THREE.Mesh(geo, mat);
          cube.position.set((x-1)*1.05, (y-1)*1.05, (z-1)*1.05);
          cube.userData = { x, y, z, index: idx(x,y,z) };
          cubeGroup.add(cube);
          cells.push(cube);
        }
      }
    }
  }

  /* --- RAYCAST FOR CLICK --- */
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  canvas.addEventListener('click', e => {
    if (!running) return;
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObjects(cubeGroup.children);
    if (hits.length) {
      const c = hits[0].object.userData;
      if (current === human && !board[c.index]) {
        makeMove(c.index, human);
        if (checkEnd()) return;
        setTimeout(aiMove, 300);
      }
    }
  });

  /* --- MOVE + RENDER MARKINGS --- */
  function makeMove(i, player){
    if (i == null) return;
    board[i] = player;
    const cube = cells[i];
    if (cube && cube.material) cube.material.color.set(player === 'X' ? 0xef4444 : 0x60a5fa);
    current = (player === 'X') ? 'O' : 'X';
  }

  /* --- WIN CHECK --- */
  function getLines(){
    const lines = [];
    const I = idx;

    // Rows + Cols + Layer diagonals
    for (let z=0;z<3;z++){
      for (let y=0;y<3;y++) lines.push([I(0,y,z), I(1,y,z), I(2,y,z)]);
      for (let x=0;x<3;x++) lines.push([I(x,0,z), I(x,1,z), I(x,2,z)]);
      lines.push([I(0,0,z), I(1,1,z), I(2,2,z)]);
      lines.push([I(2,0,z), I(1,1,z), I(0,2,z)]);
    }

    // Pillars
    for (let x=0;x<3;x++) for (let y=0;y<3;y++) lines.push([I(x,y,0), I(x,y,1), I(x,y,2)]);

    // Vertical diagonals (xz, yz)
    for (let x=0;x<3;x++){
      lines.push([I(x,0,0), I(x,1,1), I(x,2,2)]);
      lines.push([I(x,2,0), I(x,1,1), I(x,0,2)]);
    }
    for (let y=0;y<3;y++){
      lines.push([I(0,y,0), I(1,y,1), I(2,y,2)]);
      lines.push([I(2,y,0), I(1,y,1), I(0,y,2)]);
    }

    // Space diagonals
    lines.push([I(0,0,0), I(1,1,1), I(2,2,2)]);
    lines.push([I(2,0,0), I(1,1,1), I(0,2,2)]);
    lines.push([I(0,2,0), I(1,1,1), I(2,0,2)]);
    lines.push([I(2,2,0), I(1,1,1), I(0,0,2)]);

    return lines;
  }
  const LINES = getLines();

  function checkWinner(player){
    for (const L of LINES){
      if (board[L[0]]===player && board[L[1]]===player && board[L[2]]===player)
        return true;
    }
    return false;
  }
  function full(){ return board.every(v=>v); }
  function checkEnd(){
    if (checkWinner(human)) {
      recordResult('wins'); status('You win!'); running=false; return true; }
    if (checkWinner(ai)) {
      recordResult('losses'); status('AI wins.'); running=false; return true; }
    if (full() && running) { recordResult('draws'); status('Draw.'); running=false; return true; }
    return false;
  }

  /* --- AI (simple heuristics) --- */
  function aiMove(){
    if (!running) return;

    let move = null;
    // Win
    for (let i=0;i<27;i++) if (!board[i]){
      board[i]=ai; if (checkWinner(ai)){ board[i]=null; move=i; break; } board[i]=null;
    }
    // Block
    if (move===null) for (let i=0;i<27;i++) if (!board[i]){
      board[i]=human; if (checkWinner(human)){ board[i]=null; move=i; break; } board[i]=null;
    }
    // Random fallback
    if (move===null){
      const empty = board.map((v,i)=>v?null:i).filter(v=>v!==null);
      move = empty[Math.floor(Math.random()*empty.length)];
    }

    makeMove(move, ai);
    checkEnd();
  }

  /* --- UI + SCORE TRACKING --- */
  const statusEl = document.getElementById('status');
  function status(t){ statusEl.textContent = t; }

  const winsEl = document.getElementById('wins');
  const lossesEl = document.getElementById('losses');
  const drawsEl = document.getElementById('draws');

  function updateScores(){
    winsEl.textContent = localStorage.getItem('ttt3d_wins') || 0;
    lossesEl.textContent = localStorage.getItem('ttt3d_losses') || 0;
    drawsEl.textContent = localStorage.getItem('ttt3d_draws') || 0;
  }
  updateScores();

  function recordResult(type){
    const key = 'ttt3d_' + type;
    let v = Number(localStorage.getItem(key) || 0);
    localStorage.setItem(key, v+1);
    updateScores();
  }

  const restartBtn = document.getElementById('restart');
  const starterEl = document.getElementById('starter');
  restartBtn.onclick = startGame;
  starterEl.onchange = startGame;

  function startGame(){
    board = Array(27).fill(null);
    createBoard3D();
    running = true;
    current = 'X';
    human = 'X'; ai = 'O';

    if (starterEl.value === 'ai'){
      human = 'O'; ai = 'X';
      status('AI starts...');
      setTimeout(aiMove, 300);
    } else {
      status('Your move (X)');
    }
  }

  /* --- ANIMATION LOOP --- */
  function animate(){
    requestAnimationFrame(animate);
    cubeGroup.rotation.x = rotX;
    cubeGroup.rotation.y = rotY;
    renderer.render(scene, camera);
  }
  animate();

  // handle resize
  window.addEventListener('resize', resizeRenderer);
  resizeRenderer();

  startGame();

} catch (err) {
  console.error('Initialization error:', err);
  const s = document.getElementById('status'); s.textContent = 'Initialization error — see console.';
}
</script>
</body>
</html>
